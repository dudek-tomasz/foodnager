# Foodnager - Plan schematu bazy danych

## 1. Lista tabel

### `public.users`
This table is managed by Supabase Auth.

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `id` | `uuid` | `PRIMARY KEY`,  | Klucz podstawowy. |
| `email` | `VARCHAR(255)` | `NOT NULL`, `UNIQUE` | Unikalny email użytkownika. |
| `encrypted_password` | `VARCHAR` | `NOT NULL` | zaszyfrowane hasło użytkownika. |
| `username` | `text` | `UNIQUE`, `CHECK (char_length(username) >= 3)` | Unikalna nazwa użytkownika. |
| `full_name` | `text` | | Imię i nazwisko użytkownika. |
<!-- | `avatar_url` | `text` | | URL do awatara użytkownika. | -->
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas utworzenia profilu. |
| `confirmed_at` | `timestamptz` | | Czas potwierdzenia profilu przez użytkownika. |
| `updated_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas ostatniej aktualizacji profilu. |

---

### `public.units`
Tabela słownikowa przechowująca jednostki miar dla produktów.

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `id` | `bigint` | `PRIMARY KEY`, `GENERATED BY DEFAULT AS IDENTITY` | Klucz podstawowy. |
| `name` | `text` | `NOT NULL`, `UNIQUE` | Pełna nazwa jednostki (np. "gram", "sztuka"). |
| `abbreviation`| `text` | `NOT NULL`, `UNIQUE` | Skrót jednostki (np. "g", "szt."). |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas utworzenia rekordu. |

---

### `public.tags`
Tabela słownikowa przechowująca tagi (kategorie) dla przepisów.

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `id` | `bigint` | `PRIMARY KEY`, `GENERATED BY DEFAULT AS IDENTITY` | Klucz podstawowy. |
| `name` | `text` | `NOT NULL`, `UNIQUE` | Nazwa taga (np. "wegańskie", "szybki obiad"). |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas utworzenia rekordu. |

---

### `public.products`
Centralna tabela produktów. Przechowuje zarówno produkty globalne (widoczne dla wszystkich), jak i prywatne (dodane przez użytkowników).

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `id` | `bigint` | `PRIMARY KEY`, `GENERATED BY DEFAULT AS IDENTITY` | Klucz podstawowy. |
| `user_id` | `uuid` | `REFERENCES public.users(id) ON DELETE SET NULL` | Identyfikator użytkownika, który dodał produkt. `NULL` dla produktów globalnych. |
| `name` | `text` | `NOT NULL` | Nazwa produktu. |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas utworzenia rekordu. |

**Uwaga:** Unikalność nazwy produktu będzie walidowana na poziomie API (`LOWER(name)`), aby uniknąć duplikatów.

---

### `public.user_products`
Tabela reprezentująca "wirtualną lodówkę" użytkownika.

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `id` | `bigint` | `PRIMARY KEY`, `GENERATED BY DEFAULT AS IDENTITY` | Klucz podstawowy. |
| `user_id` | `uuid` | `NOT NULL`, `REFERENCES public.users(id) ON DELETE CASCADE` | Właściciel produktu. |
| `product_id` | `bigint` | `NOT NULL`, `REFERENCES public.products(id) ON DELETE CASCADE` | Powiązany produkt z globalnej tabeli. |
| `quantity` | `decimal` | `NOT NULL`, `CHECK (quantity >= 0)` | Ilość produktu. |
| `unit_id` | `bigint` | `NOT NULL`, `REFERENCES public.units(id)` | Jednostka miary. |
| `expiry_date` | `date` | | Data ważności produktu. |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas dodania produktu do lodówki. |

---

### `public.recipes`
Główna tabela przechowująca przepisy.

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `id` | `bigint` | `PRIMARY KEY`, `GENERATED BY DEFAULT AS IDENTITY` | Klucz podstawowy. |
| `user_id` | `uuid` | `NOT NULL`, `REFERENCES public.users(id) ON DELETE CASCADE` | Autor przepisu. |
| `title` | `text` | `NOT NULL` | Tytuł przepisu. |
| `description` | `text` | | Krótki opis przepisu. |
| `instructions` | `text` | `NOT NULL` | Instrukcje przygotowania. |
| `cooking_time` | `integer` | `CHECK (cooking_time > 0)` | Czas przygotowania w minutach. |
| `difficulty` | `enum('easy', 'medium', 'hard')` | | Stopień trudności. |
| `source` | `enum('user', 'api', 'ai')` | `NOT NULL`, `DEFAULT 'user'` | Źródło pochodzenia przepisu. |
| `metadata` | `jsonb` | | Dodatkowe metadane (np. z zewnętrznego API). |
| `created_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas utworzenia rekordu. |
| `updated_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas ostatniej aktualizacji rekordu. |

---

### `public.recipe_ingredients`
Tabela łącząca (wiele-do-wielu) przepisy ze składnikami (produktami).

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `recipe_id` | `bigint` | `NOT NULL`, `REFERENCES public.recipes(id) ON DELETE CASCADE` | ID przepisu. |
| `product_id` | `bigint` | `NOT NULL`, `REFERENCES public.products(id) ON DELETE CASCADE` | ID produktu. |
| `quantity` | `decimal` | `NOT NULL`, `CHECK (quantity > 0)` | Wymagana ilość produktu. |
| `unit_id` | `bigint` | `NOT NULL`, `REFERENCES public.units(id)` | Jednostka miary. |
| | | `PRIMARY KEY (recipe_id, product_id)` | Klucz złożony zapobiegający duplikatom. |

---

### `public.recipe_tags`
Tabela łącząca (wiele-do-wielu) przepisy z tagami.

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `recipe_id` | `bigint` | `NOT NULL`, `REFERENCES public.recipes(id) ON DELETE CASCADE` | ID przepisu. |
| `tag_id` | `bigint` | `NOT NULL`, `REFERENCES public.tags(id) ON DELETE CASCADE` | ID taga. |
| | | `PRIMARY KEY (recipe_id, tag_id)` | Klucz złożony zapobiegający duplikatom. |

---

### `public.cooking_history`
Tabela przechowująca historię gotowania przepisów przez użytkowników.

| Kolumna | Typ danych | Ograniczenia | Opis |
|---|---|---|---|
| `id` | `bigint` | `PRIMARY KEY`, `GENERATED BY DEFAULT AS IDENTITY` | Klucz podstawowy. |
| `user_id` | `uuid` | `NOT NULL`, `REFERENCES public.users(id) ON DELETE CASCADE` | Użytkownik, który gotował. |
| `recipe_id` | `bigint` | `NOT NULL`, `REFERENCES public.recipes(id) ON DELETE CASCADE` | Ugotowany przepis. |
| `cooked_at` | `timestamptz` | `NOT NULL`, `DEFAULT now()` | Czas ugotowania. |
| `fridge_state_before` | `jsonb` | `NOT NULL` | Stan "lodówki" przed gotowaniem. |
| `fridge_state_after` | `jsonb` | `NOT NULL` | Stan "lodówki" po gotowaniu. |

## 2. Relacje między tabelami

- **`users` → `recipes`**: Jeden-do-wielu (1:N). Użytkownik może mieć wiele przepisów.
- **`users` → `user_products`**: Jeden-do-wielu (1:N). Użytkownik może mieć wiele produktów w swojej "lodówce".
- **`users` → `products`**: Jeden-do-wielu (1:N). Użytkownik może dodać wiele własnych (prywatnych) produktów.
- **`users` → `cooking_history`**: Jeden-do-wielu (1:N). Użytkownik może mieć wiele wpisów w historii gotowania.
- **`recipes` ↔ `products`**: Wiele-do-wielu (N:M) poprzez tabelę `recipe_ingredients`.
- **`recipes` ↔ `tags`**: Wiele-do-wielu (N:M) poprzez tabelę `recipe_tags`.
- **`user_products` → `products`**: Wiele-do-jednego (N:1). Wiele wpisów w lodówkach może odnosić się do jednego produktu.
- **`user_products` → `units`**: Wiele-do-jednego (N:1). Wiele produktów w lodówce może używać tej samej jednostki.
- **`recipe_ingredients` → `units`**: Wiele-do-jednego (N:1). Wiele składników może używać tej samej jednostki.

## 3. Indeksy

W celu optymalizacji wydajności zapytań, zostaną utworzone następujące indeksy:

- **Indeksy na kluczach obcych (FK):** Automatycznie tworzone dla wszystkich kolumn z kluczami obcymi.
  - `products(user_id)`
  - `user_products(user_id, product_id, unit_id)`
  - `recipes(user_id)`
  - `recipe_ingredients(recipe_id, product_id, unit_id)`
  - `recipe_tags(recipe_id, tag_id)`
  - `cooking_history(user_id, recipe_id)`
- **Indeksy niestandardowe:**
  - `CREATE INDEX ON public.user_products (expiry_date);` - dla szybkiego filtrowania przeterminowanych produktów.
  - `CREATE INDEX ON public.recipes (source);` - dla filtrowania przepisów według źródła.
  - `CREATE INDEX ON public.products USING GIN (to_tsvector('english', name));` - dla wyszukiwania pełnotekstowego w nazwach produktów.
  - `CREATE INDEX ON public.recipes USING GIN (to_tsvector('english', title || ' ' || instructions));` - dla wyszukiwania pełnotekstowego w tytułach i instrukcjach przepisów.
  - `CREATE INDEX products_lower_name_idx ON public.products (lower(name));` - dla szybkiego, bezrozmiarowego sprawdzania unikalności produktów na poziomie API.

## 4. Zasady PostgreSQL (Row-Level Security)

RLS zostanie włączone dla wszystkich tabel przechowujących dane użytkowników, aby zapewnić izolację danych.

- **Tabele z włączonym RLS:** `users`, `user_products`, `recipes`, `products`, `cooking_history`.

### Przykładowe polityki:

- **`users`**
  - Użytkownicy mogą odczytywać wszystkie profile (dane publiczne).
    `CREATE POLICY "Allow public read access" ON public.users FOR SELECT USING (true);`
  - Użytkownicy mogą aktualizować tylko swój własny profil.
    `CREATE POLICY "Allow individual update access" ON public.users FOR UPDATE USING (auth.uid() = id);`

- **`user_products`**
  - Użytkownicy mogą zarządzać (SELECT, INSERT, UPDATE, DELETE) tylko swoimi produktami w "lodówce".
    `CREATE POLICY "Allow full access for owners" ON public.user_products FOR ALL USING (auth.uid() = user_id);`

- **`recipes`**
  - Użytkownicy mogą zarządzać (SELECT, INSERT, UPDATE, DELETE) tylko swoimi przepisami.
    `CREATE POLICY "Allow full access for owners" ON public.recipes FOR ALL USING (auth.uid() = user_id);`

- **`products`**
  - Użytkownicy mogą odczytywać wszystkie produkty globalne (`user_id` IS NULL) oraz swoje prywatne.
    `CREATE POLICY "Allow read access to public and own products" ON public.products FOR SELECT USING (user_id IS NULL OR auth.uid() = user_id);`
  - Użytkownicy mogą tworzyć nowe produkty (ustawiając `user_id` na swoje ID).
    `CREATE POLICY "Allow individual insert access" ON public.products FOR INSERT WITH CHECK (auth.uid() = user_id);`
  - Użytkownicy mogą modyfikować i usuwać tylko swoje prywatne produkty.
    `CREATE POLICY "Allow individual update/delete access" ON public.products FOR UPDATE, DELETE USING (auth.uid() = user_id);`

- **`cooking_history`**
  - Użytkownicy mogą zarządzać (SELECT, INSERT, UPDATE, DELETE) tylko swoją historią gotowania.
    `CREATE POLICY "Allow full access for owners" ON public.cooking_history FOR ALL USING (auth.uid() = user_id);`

## 5. Dodatkowe uwagi

- **Funkcje bazodanowe:** Logika aktualizacji stanu "lodówki" po ugotowaniu przepisu zostanie zaimplementowana jako funkcja PostgreSQL (`plpgsql`), aby zapewnić transakcyjność i przenieść logikę biznesową bliżej danych.
- **Typy ENUM:** Należy utworzyć niestandardowe typy `difficulty_enum` i `source_enum` przed utworzeniem tabeli `recipes`.
  - `CREATE TYPE difficulty_enum AS ENUM ('easy', 'medium', 'hard');`
  - `CREATE TYPE source_enum AS ENUM ('user', 'api', 'ai');`
- **Seeding:** Dane początkowe, takie jak jednostki (`units`) i tagi (`tags`), zostaną załadowane za pomocą skryptu `seed.sql` w ramach migracji Supabase.
- **Automatyczna aktualizacja `updated_at`:** Dla tabel `users` i `recipes` zostanie utworzony trigger, który automatycznie zaktualizuje kolumnę `updated_at` przy każdej zmianie wiersza.
